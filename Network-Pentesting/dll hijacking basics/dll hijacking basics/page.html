<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>DLL Hijacking Basics</title>
</head><body><img src="screenshot.png" /><br/>
<br/>
<br/>
<b>NB: Per exploitable intendiamo che altre applicazioni possano chiamare queste DLL!</b><br/>
<b>DLLMAIN()</b>&nbsp;è una funzione usata ogni volta che viene chiamata la DLL, come startup activity della DLL.<br/>
I file .exe chiamano le DLL dal disco usando <b>loadlibrary(), </b>per poi cercare la funzione necessaria da runnare<br/>
usando la funzione <b>getprocaddress().<br/>
</b><b><br/>
In pratica: tramite loadlibrary() e getprocaddress(), vengono caricate le DLL in memoria<br/>
</b><b>e le loro funzioni sono rese accessibili.</b><br/>
<img src="screenshot 2.png" /><br/>
<br/>
<br/>
<br/>
<img src="screenshot 3.png" /><br/>
<br/>
<br/>
<br/>
<img src="screenshot 4.png" /><br/>
<br/>
<br/>
<br/>
<img src="1.png" /><br/>
<br/>
La SafeDLLSearchMode cerca di non caricare subito qualsiasi cosa<br/>
si trovi nella current directory, ma cerca di trovare la DLL in altre parti<br/>
del sistema.<br/>
<img src="screenshot 5.png" /><br/>
<br/>
<br/>
In breve: se un app segue un certo tipo di ordine, possiamo vedere se è possibile<br/>
caricare quella DLL nella path oppure anche prima (specialmente se la DLL è missing)!<br/>
<img src="screenshot 6.png" /><br/>
<br/>
<br/>
<br/>
<img src="screenshot 7.png" /><br/>
<br/>
<br/>
<br/>
<img src="1 2.png" /><br/>
<br/>
<br/>
<br/>
Ora per vedere l'exploit e tutto,<br/>
abbiamo necessità di "Procmon" e <br/>
di altre utility di SysinternalSuite<br/>
<img src="1 3.png" /><br/>
<br/>
<br/>
<img src="1 4.png" /><br/>
<br/>
<br/>
Il tool è utile perché ci indica quale DLL un eseguibile carica,<br/>
se è riuscito a caricarle e la loro path!<br/>
<br/>
<br/>
Aggiungiamo il nome dell'eseguibile<br/>
da analizzare (quello di Kaspersky)<br/>
<img src="1 5.png" /><br/>
<br/>
Aggiungiamo un altro filtro interessane:<br/>
dove la path contiene il DLL!<br/>
<img src="1 6.png" /><br/>
<br/>
<br/>
Quando esce "NAME NOT FOUND", indica che la DLL non è stata trovata<br/>
nella path!<br/>
Da qui possiamo vedere per DLL Hijacking!<br/>
<img src="1 7.png" /><br/>
<br/>
<br/>
Aggiungiamo un altro filtro,<br/>
dove cerchiamo solo quelli col nome not found:<br/>
<img src="1 8.png" /><br/>
<br/>
<img src="1 9.png" /><br/>
<br/>
Se vediamo la funzione evidenziata prima,<br/>
possiamo notare che cerca di trovare<br/>
una DLL da aprire!<br/>
<img src="1 10.png" /><br/>
<br/>
<br/>
La nostra azione da fare per l'hijacking è molto semplice:<br/>
creare un dll malevolo chiamato come il DLL che sta cercando di trovare<br/>
(nel nostro caso: <b>kavremoverENU.dll</b>)<br/>
<br/>
Ora creiamo la nosta DLL malevola:<br/>
NB: lo switch con fdwReason è importante!<br/>
<img src="1 11.png" /><br/>
<br/>
<br/>
Ora compiliamo il codice precedente in una DLL shared:<br/>
<img src="1 12.png" /><br/>
<br/>
<br/>
<br/>
Ora mettiamo il fine sulla macchina avversaria, rinominiamolo ed<br/>
inseriamolo nella path necessaria!</body></html>